# -*- coding: utf-8 -*-
"""exe.php

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1THYQ8E9vS2bEJ_T-PGgpQ3nRZrP_ktcu
"""

# Playfair Cipher in Python

# Playfair Cipher Implementation

def create_playfair_matrix(key):
    # Create a 5x5 matrix using the key
    matrix = []
    seen = set()
    key = key.upper().replace("J", "I")  # Replace 'J' with 'I'

    # Add unique characters from the key
    for char in key:
        if char not in seen and char.isalpha():
            seen.add(char)
            matrix.append(char)

    # Fill the matrix with remaining letters
    for char in "ABCDEFGHIKLMNOPQRSTUVWXYZ":
        if char not in seen:
            matrix.append(char)

    # Convert the list into a 5x5 matrix
    return [matrix[i:i + 5] for i in range(0, 25, 5)]

def find_position(matrix, char):
    # Find the row and column of a character in the matrix
    for row in range(5):
        for col in range(5):
            if matrix[row][col] == char:
                return row, col

def playfair_encrypt(text, matrix):
    text = text.upper().replace("J", "I").replace(" ", "")
    encrypted_text = ""
    i = 0

    # Iterate through pairs of characters
    while i < len(text):
        a = text[i]
        b = text[i + 1] if i + 1 < len(text) else 'X'
        if a == b:
            b = 'X'

        row_a, col_a = find_position(matrix, a)
        row_b, col_b = find_position(matrix, b)

        # Apply Playfair rules
        if row_a == row_b:
            encrypted_text += matrix[row_a][(col_a + 1) % 5]
            encrypted_text += matrix[row_b][(col_b + 1) % 5]
        elif col_a == col_b:
            encrypted_text += matrix[(row_a + 1) % 5][col_a]
            encrypted_text += matrix[(row_b + 1) % 5][col_b]
        else:
            encrypted_text += matrix[row_a][col_b]
            encrypted_text += matrix[row_b][col_a]

        i += 2

    return encrypted_text

# Example usage
key = "KEYWORD"
text = "HELLO WORLD"
matrix = create_playfair_matrix(key)
encrypted_text = playfair_encrypt(text, matrix)
print(f"Encrypted Text: {encrypted_text}")

# Playfair Cipher in Python

def create_playfair_matrix(key):
    matrix = []
    seen = set()
    key = key.upper().replace("J", "I")  # Replace 'J' with 'I'

    # Add key characters to the matrix
    for char in key:
        if char not in seen and char.isalpha():
            seen.add(char)
            matrix.append(char)

    # Fill matrix with remaining letters
    for char in "ABCDEFGHIKLMNOPQRSTUVWXYZ":
        if char not in seen:
            matrix.append(char)

    # Convert to 5x5 matrix
    matrix = [matrix[i:i + 5] for i in range(0, 25, 5)]
    return matrix

def find_position(matrix, char):
    # Find the row and column of a character in the matrix
    for row in range(5):
        for col in range(5):
            if matrix[row][col] == char:
                return row, col

def playfair_encrypt(text, matrix):
    text = text.upper().replace("J", "I")
    encrypted_text = ""

    # Iterate through text pairs
    i = 0
    while i < len(text):
        a = text[i]
        b = text[i + 1] if i + 1 < len(text) else 'X'
        if a == b:
            b = 'X'
        row_a, col_a = find_position(matrix, a)
        row_b, col_b = find_position(matrix, b)

        # Apply Playfair Cipher rules
        if row_a == row_b:
            encrypted_text += matrix[row_a][(col_a + 1) % 5]
            encrypted_text += matrix[row_b][(col_b + 1) % 5]
        elif col_a == col_b:
            encrypted_text += matrix[(row_a + 1) % 5][col_a]
            encrypted_text += matrix[(row_b + 1) % 5][col_b]
        else:
            encrypted_text += matrix[row_a][col_b]
            encrypted_text += matrix[row_b][col_a]

        i += 2

    return encrypted_text

# Example usage
key = "KEYWORD"
text = "HELLO"
matrix = create_playfair_matrix(key)
encrypted = playfair_encrypt(text, matrix)
print(f"Encrypted Text: {encrypted}")

#2. Hill Cipher (Python)

import numpy as np

def hill_encrypt(message, key_matrix):
    # Convert message to numerical values (A=0, B=1, ..., Z=25)
    message_vector = [ord(char) - 65 for char in message.upper()]
    message_vector = np.array(message_vector).reshape(-1, len(key_matrix))

    # Encrypt by matrix multiplication
    cipher_matrix = (np.dot(message_vector, key_matrix) % 26).flatten()
    encrypted_text = ''.join([chr(num + 65) for num in cipher_matrix])

    return encrypted_text

# Example usage
key_matrix = np.array([[6, 24], [1, 13]])  # 2x2 key matrix
message = "HI"
encrypted = hill_encrypt(message, key_matrix)
print(f"Encrypted Text: {encrypted}")

#3 Keyless Transposition Cipher
def keyless_transposition_encrypt(text):
    # Split text into even and odd indexed characters
    even_chars = text[0::2]
    odd_chars = text[1::2]
    return even_chars + odd_chars

# Example usage
text = "HELLO"
encrypted_text = keyless_transposition_encrypt(text)
print(f"Encrypted Text: {encrypted_text}")

#4. Additive Cipher (Python)
def additive_encrypt(text, shift):
    encrypted_text = ""
    for char in text.upper():
        if char.isalpha():
            encrypted_text += chr(((ord(char) - 65 + shift) % 26) + 65)
    return encrypted_text

# Example usage
text = "HELLO"
shift = 3
encrypted = additive_encrypt(text, shift)
print(f"Encrypted Text: {encrypted}")

#5. Key Generation Algorithm of DES (Python Skeleton)
def des_key_generation(key):
    # Placeholder for key generation logic
    # Perform permutations and shifts to generate subkeys
    subkeys = ["Subkey1", "Subkey2", "Subkey3"]
    return subkeys

# Example usage
key = "133457799BBCDFF1"
subkeys = des_key_generation(key)
print(f"Generated Subkeys: {subkeys}")

pip install pycryptodome

# Import necessary modules


from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes

# Set AES block size and key size
BLOCK_SIZE = 16  # AES block size is 128 bits
KEY_SIZE = 16  # AES-128 uses a 16-byte (128-bit) key (use 24 for AES-192 or 32 for AES-256)

# Generate a random AES key
key = get_random_bytes(KEY_SIZE)
print(f"AES Key: {key.hex()}")

# Generate a random Initialization Vector (IV)
iv = get_random_bytes(BLOCK_SIZE)
print(f"IV: {iv.hex()}")

# Function to encrypt data
def aes_encrypt(data, key, iv):
    # Initialize AES cipher in CBC mode
    cipher = AES.new(key, AES.MODE_CBC, iv)

    # Pad data to be a multiple of BLOCK_SIZE
    padded_data = pad(data.encode(), BLOCK_SIZE)

    # Encrypt the padded data
    ciphertext = cipher.encrypt(padded_data)

    return ciphertext

# Function to decrypt data
def aes_decrypt(ciphertext, key, iv):
    # Initialize AES cipher in CBC mode
    cipher = AES.new(key, AES.MODE_CBC, iv)

    # Decrypt the ciphertext
    decrypted_data = cipher.decrypt(ciphertext)

    # Unpad the decrypted data
    unpadded_data = unpad(decrypted_data, BLOCK_SIZE)

    return unpadded_data.decode()

# Example usage
if __name__ == "__main__":
    # Input data to encrypt
    plaintext = "This is a secret message."
    print(f"Plaintext: {plaintext}")

    # Encrypt the data
    encrypted_data = aes_encrypt(plaintext, key, iv)
    print(f"Encrypted Data: {encrypted_data.hex()}")

    # Decrypt the data
    decrypted_data = aes_decrypt(encrypted_data, key, iv)
    print(f"Decrypted Data: {decrypted_data}")

#7 Keyed Cipher (Example Using Caesar Cipher)
def keyed_cipher_encrypt(text, key):
    return additive_encrypt(text, key)

# Example usage
text = "HELLO"
key = 5
encrypted_text = keyed_cipher_encrypt(text, key)
print(f"Encrypted Text: {encrypted_text}")

#8. Diffie-Hellman Key Exchange (Python)
def diffie_hellman(p, g, private_a, private_b):
    # Calculate public keys
    public_a = (g ** private_a) % p
    public_b = (g ** private_b) % p

    # Calculate shared secret
    shared_secret_a = (public_b ** private_a) % p
    shared_secret_b = (public_a ** private_b) % p

    return shared_secret_a, shared_secret_b

# Example usage
p = 23  # Prime number
g = 5   # Primitive root
private_a = 6
private_b = 15
shared_a, shared_b = diffie_hellman(p, g, private_a, private_b)
print(f"Shared Secret: {shared_a}")

#9
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Random import get_random_bytes

def rsa_encrypt_decrypt(message):
    key = RSA.generate(2048)
    cipher = PKCS1_OAEP.new(key)
    ciphertext = cipher.encrypt(message.encode())
    plaintext = cipher.decrypt(ciphertext)
    return ciphertext, plaintext

# Example usage:
message = "HELLO"
ciphertext, plaintext = rsa_encrypt_decrypt(message)
print("Ciphertext:", ciphertext)
print("Plaintext:", plaintext.decode())

#10. Multiplicative Cipher (Python)
def multiplicative_encrypt(text, key):
    encrypted_text = ""
    for char in text.upper():
        if char.isalpha():
            encrypted_text += chr(((ord(char) - 65) * key % 26) + 65)
    return encrypted_text

# Example usage
text = "HELLO"
key = 5
encrypted = multiplicative_encrypt(text, key)
print(f"Encrypted Text: {encrypted}")

#11. Affine Cipher (Python)
def affine_encrypt(text, a, b):
    encrypted_text = ""
    for char in text.upper():
        if char.isalpha():
            encrypted_text += chr(((a * (ord(char) - 65) + b) % 26) + 65)
    return encrypted_text

# Example usage
text = "HELLO"
a = 5
b = 8
encrypted = affine_encrypt(text, a, b)
print(f"Encrypted Text: {encrypted}")