# -*- coding: utf-8 -*-
"""Copy of Crypto All Labs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-leicJPesVN2U6_kQxZ6qMEMB4kXQZND

***Lab - 01***

1. Implement the additive cipher.
"""

def additive_cipher(text, shift):
    result = ""
    for char in text:
        if char.isalpha():  # Check if the character is a letter
            shift_amount = shift % 26
            ascii_offset = 65 if char.isupper() else 97
            result += chr((ord(char) - ascii_offset + shift_amount) % 26 + ascii_offset)
        else:
            result += char  # Non-alphabet characters are added as is
    return result

# Get user input
text = input("Enter the text to encrypt: ")
shift = int(input("Enter the shift amount: "))

# Encrypt the text
encrypted_text = additive_cipher(text, shift)
print("Encrypted text:", encrypted_text)

"""***Lab - 02***

1. Implement the Multiplicative Cipher.
"""

def main():
    # Handle user input and perform encryption and decryption
    plain_text = input("Enter the plain text: ")

    while True:
        try:
            key = int(input("Enter the key (an integer): "))
            break
        except ValueError:
            print("Invalid input. Please enter an integer value for the key.")

    if gcd(key, 26) != 1:
        print("The key is not valid. It must be coprime with 26.")
        return

    cipher_text = encrypt(plain_text, key)
    print("Encrypted Text: ", cipher_text)

    decrypted_text = decrypt(cipher_text, key)
    print("Decrypted Text: ", decrypted_text)

if __name__ == "__main__":
    main()

"""2. Implement the Affine Cipher."""

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def mod_inverse(a, m):
    a = a % m
    for x in range(1, m):
        if (a * x) % m == 1:
            return x
    return None

def affine_encrypt(plaintext, a, b):
    # Ensure a is coprime to m
    m = 26
    if gcd(a, m) != 1:
        raise ValueError(f"a ({a}) and m ({m}) are not coprime. Choose a different value for a.")

    # Encrypt the plaintext
    ciphertext = ''
    for char in plaintext:
        if char.isalpha():
            x = ord(char.lower()) - ord('a')
            encrypted_char = (a * x + b) % m
            cipher_char = chr(encrypted_char + ord('a'))
            if char.isupper():
                cipher_char = cipher_char.upper()
            ciphertext += cipher_char
        else:
            ciphertext += char

    return ciphertext

def affine_decrypt(ciphertext, a, b):
    # Ensure a is coprime to m
    m = 26
    if gcd(a, m) != 1:
        raise ValueError(f"a ({a}) and m ({m}) are not coprime. Choose a different value for a.")

    # Find modular inverse of a
    a_inv = mod_inverse(a, m)
    if a_inv is None:
        raise ValueError(f"Modular inverse of a ({a}) does not exist under modulo m ({m}).")

    # Decrypt the ciphertext
    plaintext = ''
    for char in ciphertext:
        if char.isalpha():
            y = ord(char.lower()) - ord('a')
            decrypted_char = (a_inv * (y - b)) % m
            plain_char = chr(decrypted_char + ord('a'))
            if char.isupper():
                plain_char = plain_char.upper()
            plaintext += plain_char
        else:
            plaintext += char

    return plaintext

# Example usage
if __name__ == "__main__":
    plaintext = input("Enter the plaintext: ")
    a = int(input("Enter the value for 'a' (must be coprime to 26): "))
    b = int(input("Enter the value for 'b': "))

    encrypted_text = affine_encrypt(plaintext, a, b)
    print(f"Encrypted text/Cipher text : {encrypted_text}")

    decrypted_text = affine_decrypt(encrypted_text, a, b)
    print(f"Decrypted text: {decrypted_text}")

"""***Lab - 03***

1. Implement the Playfair Cipher.
"""

def create_playfair_matrix(key):
    key = "".join(dict.fromkeys(key))  # Remove duplicates
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"  # Include all letters, including 'J'
    matrix = []
    for char in key:
        if char in alphabet:
            matrix.append(char)
            alphabet = alphabet.replace(char, "")
    matrix.extend(list(alphabet))
    return [matrix[i:i+5] for i in range(0, 25, 5)]

def prepare_text(plaintext):
    plaintext = plaintext.upper().replace(" ", "")
    prepared_text = ""
    i = 0
    while i < len(plaintext):
        prepared_text += plaintext[i]
        if i+1 < len(plaintext) and plaintext[i] == plaintext[i+1]:
            prepared_text += "X"
        elif i+1 < len(plaintext):
            prepared_text += plaintext[i+1]
        i += 2
    if len(prepared_text) % 2 != 0:
        prepared_text += "X"
    return prepared_text

def find_position(matrix, char):
    for i, row in enumerate(matrix):
        if char in row:
            return i, row.index(char)
    raise ValueError(f"Character {char} not found in matrix")

def encrypt_pair(matrix, char1, char2):
    row1, col1 = find_position(matrix, char1)
    row2, col2 = find_position(matrix, char2)

    if row1 == row2:
        return matrix[row1][(col1 + 1) % 5] + matrix[row2][(col2 + 1) % 5]
    elif col1 == col2:
        return matrix[(row1 + 1) % 5][col1] + matrix[(row2 + 1) % 5][col2]
    else:
        return matrix[row1][col2] + matrix[row2][col1]

def playfair_encrypt(plaintext, key):
    matrix = create_playfair_matrix(key)
    prepared_text = prepare_text(plaintext)
    cipher_text = ""

    for i in range(0, len(prepared_text), 2):
        cipher_text += encrypt_pair(matrix, prepared_text[i], prepared_text[i+1])

    return cipher_text

# Get user input
key = input("Enter the key: ").upper().replace(" ", "")
plaintext = input("Enter the plaintext: ")

try:
    ciphertext = playfair_encrypt(plaintext, key)
    print("Ciphertext:", ciphertext)
except ValueError as e:
    print(e)

"""2. Implement the Hill Cipher."""

import numpy as np

def create_key_matrix(key, n):
    key = key.upper().replace(" ", "")
    key_matrix = []
    for i in range(n):
        row = [ord(char) % 65 for char in key[i*n:(i+1)*n]]
        key_matrix.append(row)
    return np.array(key_matrix)

def prepare_text(plaintext, n):
    plaintext = plaintext.upper().replace(" ", "")
    while len(plaintext) % n != 0:
        plaintext += "X"
    return plaintext

def hill_cipher_encrypt(plaintext, key, n):
    key_matrix = create_key_matrix(key, n)
    plaintext = prepare_text(plaintext, n)

    cipher_text = ""

    for i in range(0, len(plaintext), n):
        text_vector = [ord(char) % 65 for char in plaintext[i:i+n]]
        text_vector = np.array(text_vector)
        cipher_vector = np.dot(key_matrix, text_vector) % 26
        cipher_text += ''.join(chr(int(num) + 65) for num in cipher_vector)

    return cipher_text

# Get user input
key = input("Enter the key (length should be a perfect square): ")
n = int(len(key)**0.5)  # Determine the matrix size (n x n)
if n * n != len(key):
    print("Error: The length of the key must be a perfect square.")
else:
    plaintext = input("Enter the plaintext: ")
    ciphertext = hill_cipher_encrypt(plaintext, key, n)
    print("Ciphertext:", ciphertext)

"""
3. Implement Key less Transposition."""

def keyless_transposition_encrypt(plaintext, num_columns):
    # Remove leading/trailing spaces and prepare the grid
    plaintext = plaintext.replace(" ", "")
    num_rows = (len(plaintext) + num_columns - 1) // num_columns  # Calculate number of rows

    # Fill the grid
    grid = [['' for _ in range(num_columns)] for _ in range(num_rows)]
    index = 0
    for row in range(num_rows):
        for col in range(num_columns):
            if index < len(plaintext):
                grid[row][col] = plaintext[index]
                index += 1

    # Read columns to form ciphertext
    cipher_text = ''.join(grid[row][col] for col in range(num_columns) for row in range(num_rows))

    return cipher_text

def keyless_transposition_decrypt(ciphertext, num_columns):
    num_rows = (len(ciphertext) + num_columns - 1) // num_columns
    grid = [['' for _ in range(num_columns)] for _ in range(num_rows)]

    # Fill the grid with ciphertext characters column by column
    index = 0
    for col in range(num_columns):
        for row in range(num_rows):
            if index < len(ciphertext):
                grid[row][col] = ciphertext[index]
                index += 1

    # Read rows to form plaintext
    plaintext = ''.join(grid[row][col] for row in range(num_rows) for col in range(num_columns))

    # Reintroduce spaces and special characters based on original length
    original_length = len(ciphertext)
    original_plaintext = plaintext[:original_length]

    return original_plaintext

# Get user input
plaintext = input("Enter the plaintext: ")
num_columns = int(input("Enter the number of columns: "))

# Remove leading/trailing spaces from plaintext
plaintext = plaintext.replace(" ", "")

ciphertext = keyless_transposition_encrypt(plaintext, num_columns)
print("Ciphertext:", ciphertext)

# Decrypt to verify
decrypted_text = keyless_transposition_decrypt(ciphertext, num_columns)
print("Decrypted Text:", decrypted_text)

"""***Lab - 04***

1. Implement the Keyed Cipher.
"""

def keyed_cipher_encrypt(plaintext, key):
    # Removing duplicates from the key
    key = ''.join(sorted(set(key), key=key.index))

    # Creating the alphabet list without the letters in the key
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    remaining_letters = ''.join([ch for ch in alphabet if ch not in key])

    # Creating the keyed alphabet
    keyed_alphabet = key + remaining_letters

    # Creating encryption dictionary
    encryption_dict = {alphabet[i]: keyed_alphabet[i] for i in range(len(alphabet))}

    # Encrypting the plaintext
    ciphertext = ''
    for char in plaintext.upper():
        if char in alphabet:
            ciphertext += encryption_dict[char]
        else:
            ciphertext += char

    return ciphertext

def keyed_cipher_decrypt(ciphertext, key):
    # Removing duplicates from the key
    key = ''.join(sorted(set(key), key=key.index))

    # Creating the alphabet list without the letters in the key
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    remaining_letters = ''.join([ch for ch in alphabet if ch not in key])

    # Creating the keyed alphabet
    keyed_alphabet = key + remaining_letters

    # Creating decryption dictionary
    decryption_dict = {keyed_alphabet[i]: alphabet[i] for i in range(len(alphabet))}

    # Decrypting the ciphertext
    plaintext = ''
    for char in ciphertext.upper():
        if char in keyed_alphabet:
            plaintext += decryption_dict[char]
        else:
            plaintext += char

    return plaintext

# Input from the user
text = input("Enter the text to encrypt: ")
key = input("Enter the key: ")

# Encrypting the text
encrypted_text = keyed_cipher_encrypt(text, key)
print("Encrypted Text:", encrypted_text)

# Decrypting the text
decrypted_text = keyed_cipher_decrypt(encrypted_text, key)
print("Decrypted Text:", decrypted_text)

"""2. Implement the Diffie Hellman Key exchange Protocol."""

import random

def diffie_hellman_key_exchange(p, g, a, b):
    # Calculate public keys
    A = pow(g, a, p)  # A = g^a mod p
    B = pow(g, b, p)  # B = g^b mod p

    # Calculate shared secret keys
    shared_secret_a = pow(B, a, p)  # shared_secret_a = B^a mod p
    shared_secret_b = pow(A, b, p)  # shared_secret_b = A^b mod p

    return A, B, shared_secret_a, shared_secret_b

def extend_shared_secret(shared_secret, length):
    shared_secret_str = str(shared_secret)
    extended_secret = (shared_secret_str * (length // len(shared_secret_str) + 1))[:length]
    return extended_secret

def encrypt_secret(secret, shared_secret):
    extended_secret = extend_shared_secret(shared_secret, len(secret))
    encrypted_secret = ''.join(chr(ord(c) ^ ord(k)) for c, k in zip(secret, extended_secret))
    return encrypted_secret

def decrypt_secret(encrypted_secret, shared_secret):
    extended_secret = extend_shared_secret(shared_secret, len(encrypted_secret))
    decrypted_secret = ''.join(chr(ord(c) ^ ord(k)) for c, k in zip(encrypted_secret, extended_secret))
    return decrypted_secret

# Input from the user
p = int(input("Enter a prime number p: "))
g = int(input("Enter a primitive root modulo p (g): "))
a = int(input("Enter the private key for the first party (a): "))
b = int(input("Enter the private key for the second party (b): "))

# Secret to be shared
secret = input("Enter the secret to be shared (string): ")

# Perform Diffie-Hellman Key Exchange
A, B, shared_secret_a, shared_secret_b = diffie_hellman_key_exchange(p, g, a, b)

# Display the public keys
print(f"First party's public key (A): {A}")
print(f"Second party's public key (B): {B}")

# Encrypt the secret using the shared secret
encrypted_secret = encrypt_secret(secret, shared_secret_a)
print(f"Encrypted Secret: {encrypted_secret}")

# Decrypt the secret using the shared secret
decrypted_secret = decrypt_secret(encrypted_secret, shared_secret_b)
print(f"Decrypted Secret: {decrypted_secret}")

# Validate that the decrypted secret matches the original
if decrypted_secret == secret:
    print("The decrypted secret matches the original secret. Secure communication was successful.")
else:
    print("The decrypted secret does not match the original secret. Something went wrong.")

"""***Lab - 05***

1. Implement the key generation algorithm of DES.
"""

# Permutation and shift tables used in DES key generation
PC1 = [57, 49, 41, 33, 25, 17, 9,
       1, 58, 50, 42, 34, 26, 18,
       10, 2, 59, 51, 43, 35, 27,
       19, 11, 3, 60, 52, 44, 36,
       63, 55, 47, 39, 31, 23, 15,
       7, 62, 54, 46, 38, 30, 22,
       14, 6, 61, 53, 45, 37, 29,
       21, 13, 5, 28, 20, 12, 4]

PC2 = [14, 17, 11, 24, 1, 5,
       3, 28, 15, 6, 21, 10,
       23, 19, 12, 4, 26, 8,
       16, 7, 27, 20, 13, 2,
       41, 52, 31, 37, 47, 55,
       30, 40, 51, 45, 33, 48,
       44, 49, 39, 56, 34, 53,
       46, 42, 50, 36, 29, 32]

# Number of left shifts per round
SHIFT_SCHEDULE = [1, 1, 2, 2, 2, 2, 2, 2,
                  1, 2, 2, 2, 2, 2, 2, 1]

# Function to shift a list to the left
def left_shift(lst, n):
    return lst[n:] + lst[:n]

# Function to generate 16 subkeys
def generate_subkeys(key_64bit):
    key_56bit = [key_64bit[i - 1] for i in PC1]
    C, D = key_56bit[:28], key_56bit[28:]

    subkeys = []
    for i in range(16):
        C = left_shift(C, SHIFT_SCHEDULE[i])
        D = left_shift(D, SHIFT_SCHEDULE[i])
        combined = C + D
        subkey = [combined[j - 1] for j in PC2]
        subkeys.append(subkey)

    return subkeys

# Convert a string to a list of bits
def string_to_bit_list(s):
    bit_list = []
    for char in s:
        bit_list.extend([int(b) for b in format(ord(char), '08b')])
    return bit_list

# Get the 64-bit key from user input
key_input = input("Enter a 64-bit key as an 8-character string: ")
if len(key_input) != 8:
    raise ValueError("Key must be exactly 8 characters long.")

key_64bit = string_to_bit_list(key_input)

# Generate the subkeys
subkeys = generate_subkeys(key_64bit)

# Display the subkeys
for i, subkey in enumerate(subkeys):
    print(f"Subkey {i+1}: {''.join(map(str, subkey))}")

"""***Lab - 06***

1. Implement the complete DES algorithm.
"""

!pip install pycryptodome

from Crypto.Cipher import DES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad

def des_encrypt(plaintext, key):
    cipher = DES.new(key, DES.MODE_ECB)
    padded_text = pad(plaintext.encode(), DES.block_size)
    encrypted_text = cipher.encrypt(padded_text)
    return encrypted_text

def des_decrypt(encrypted_text, key):
    cipher = DES.new(key, DES.MODE_ECB)
    decrypted_padded_text = cipher.decrypt(encrypted_text)
    decrypted_text = unpad(decrypted_padded_text, DES.block_size)
    return decrypted_text.decode()

# Generate a random 8-byte key
key = get_random_bytes(8)

# Input from the user
plaintext = input("Enter the string to be encrypted: ")

# Encrypt the plaintext
encrypted_text = des_encrypt(plaintext, key)
print(f"Encrypted string (hex): {encrypted_text.hex()}")

# Decrypt the encrypted text
decrypted_text = des_decrypt(encrypted_text, key)
print(f"Decrypted string: {decrypted_text}")

# Compare and display whether they are the same
if plaintext == decrypted_text:
    print("The decrypted string is the same as the original.")
else:
    print("The decrypted string is different from the original.")

"""***Lab - 07***

1. Implement the complete AES algorithm.
"""

pip install pycryptodome

from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes

def encrypt_AES(plain_text, key):
    # Create AES cipher object with the given key
    cipher = AES.new(key, AES.MODE_CBC)  # Using CBC mode

    # Pad the plain text to ensure it is a multiple of the AES block size (16 bytes)
    padded_text = pad(plain_text.encode('utf-8'), AES.block_size)

    # Encrypt the plain text
    cipher_text = cipher.encrypt(padded_text)

    # Return the cipher text and the initialization vector (IV)
    return cipher_text, cipher.iv

def decrypt_AES(cipher_text, key, iv):
    # Create AES cipher object with the given key and IV
    cipher = AES.new(key, AES.MODE_CBC, iv=iv)

    # Decrypt the cipher text
    decrypted_text = cipher.decrypt(cipher_text)

    # Unpad the decrypted text
    plain_text = unpad(decrypted_text, AES.block_size)

    return plain_text.decode('utf-8')

def main():
    # Take plain text input from user
    plain_text = input("Enter the plain text to encrypt: ")

    # Generate a random AES key (128 bits = 16 bytes)
    key = get_random_bytes(16)

    # Encrypt the plain text
    cipher_text, iv = encrypt_AES(plain_text, key)
    print(f"Cipher Text (in bytes): {cipher_text}")
    print(f"IV (Initialization Vector): {iv}")

    # Decrypt the cipher text
    decrypted_text = decrypt_AES(cipher_text, key, iv)
    print(f"Decrypted Text: {decrypted_text}")

if __name__ == "__main__":
    main()

"""***Lab -08***

1. Implement the RSA Algorithm.
"""

import random

# Function to calculate gcd of two numbers
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

# Function to calculate the modular inverse of e mod phi
def modinv(e, phi):
    d_old, d_new = 0, 1
    r_old, r_new = phi, e
    while r_new != 0:
        quotient = r_old // r_new
        r_old, r_new = r_new, r_old - quotient * r_new
        d_old, d_new = d_new, d_old - quotient * d_new
    if r_old == 1:
        return d_old % phi

# Function to calculate power mod n
def power_mod(base, exp, mod):
    result = 1
    while exp > 0:
        if exp % 2 == 1:
            result = (result * base) % mod
        base = (base * base) % mod
        exp //= 2
    return result

# Function to generate prime numbers
def generate_prime(start=100, end=300):
    primes = [num for num in range(start, end) if all(num % i != 0 for i in range(2, int(num**0.5)+1))]
    return random.choice(primes)

# RSA Key generation
def generate_rsa_keys():
    p = generate_prime()
    q = generate_prime()
    n = p * q
    phi = (p - 1) * (q - 1)

    # Choose e such that 1 < e < phi and gcd(e, phi) = 1
    e = random.choice([x for x in range(3, phi, 2) if gcd(x, phi) == 1])

    # Calculate d such that (d * e) % phi = 1
    d = modinv(e, phi)

    return (e, n), (d, n)  # public key (e, n), private key (d, n)

# Encrypt message using public key
def encrypt(plaintext, public_key):
    e, n = public_key
    ciphertext = [power_mod(ord(char), e, n) for char in plaintext]
    return ciphertext

# Decrypt ciphertext using private key
def decrypt(ciphertext, private_key):
    d, n = private_key
    decrypted_message = ''.join([chr(power_mod(char, d, n)) for char in ciphertext])
    return decrypted_message

# Main Function
if __name__ == "__main__":
    # User input
    plaintext = input("Enter the message to be encrypted: ")

    # Generate RSA keys
    public_key, private_key = generate_rsa_keys()
    print(f"Public Key: {public_key}")
    print(f"Private Key: {private_key}")

    # Encrypt the message
    ciphertext = encrypt(plaintext, public_key)
    print(f"Encrypted Message: {ciphertext}")

    # Decrypt the message
    decrypted_message = decrypt(ciphertext, private_key)
    print(f"Decrypted Message: {decrypted_message}")