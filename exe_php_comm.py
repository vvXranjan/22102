# -*- coding: utf-8 -*-
"""exe.php.comm

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1THYQ8E9vS2bEJ_T-PGgpQ3nRZrP_ktcu
"""

# Playfair Cipher in Python

# Playfair Cipher Implementation

def create_playfair_matrix(key):
    # Create a 5x5 matrix using the key
    matrix = []
    seen = set()
    key = key.upper().replace("J", "I")  # Replace 'J' with 'I'

    # Add unique characters from the key
    for char in key:
        if char not in seen and char.isalpha():
            seen.add(char)
            matrix.append(char)

    # Fill the matrix with remaining letters
    for char in "ABCDEFGHIKLMNOPQRSTUVWXYZ":
        if char not in seen:
            matrix.append(char)

    # Convert the list into a 5x5 matrix
    return [matrix[i:i + 5] for i in range(0, 25, 5)]

def find_position(matrix, char):
    # Find the row and column of a character in the matrix
    for row in range(5):
        for col in range(5):
            if matrix[row][col] == char:
                return row, col

def playfair_encrypt(text, matrix):
    text = text.upper().replace("J", "I").replace(" ", "")
    encrypted_text = ""
    i = 0

    # Iterate through pairs of characters
    while i < len(text):
        a = text[i]
        b = text[i + 1] if i + 1 < len(text) else 'X'
        if a == b:
            b = 'X'

        row_a, col_a = find_position(matrix, a)
        row_b, col_b = find_position(matrix, b)

        # Apply Playfair rules
        if row_a == row_b:
            encrypted_text += matrix[row_a][(col_a + 1) % 5]
            encrypted_text += matrix[row_b][(col_b + 1) % 5]
        elif col_a == col_b:
            encrypted_text += matrix[(row_a + 1) % 5][col_a]
            encrypted_text += matrix[(row_b + 1) % 5][col_b]
        else:
            encrypted_text += matrix[row_a][col_b]
            encrypted_text += matrix[row_b][col_a]

        i += 2

    return encrypted_text

# Example usage
key = "KEYWORD"
text = "HELLO WORLD"
matrix = create_playfair_matrix(key)
encrypted_text = playfair_encrypt(text, matrix)
print(f"Encrypted Text: {encrypted_text}")

# Playfair Cipher in Python

def create_playfair_matrix(key):
    matrix = []
    seen = set()
    key = key.upper().replace("J", "I")  # Replace 'J' with 'I'

    # Add key characters to the matrix
    for char in key:
        if char not in seen and char.isalpha():
            seen.add(char)
            matrix.append(char)

    # Fill matrix with remaining letters
    for char in "ABCDEFGHIKLMNOPQRSTUVWXYZ":
        if char not in seen:
            matrix.append(char)

    # Convert to 5x5 matrix
    matrix = [matrix[i:i + 5] for i in range(0, 25, 5)]
    return matrix

def find_position(matrix, char):
    # Find the row and column of a character in the matrix
    for row in range(5):
        for col in range(5):
            if matrix[row][col] == char:
                return row, col

def playfair_encrypt(text, matrix):
    text = text.upper().replace("J", "I")
    encrypted_text = ""

    # Iterate through text pairs
    i = 0
    while i < len(text):
        a = text[i]
        b = text[i + 1] if i + 1 < len(text) else 'X'
        if a == b:
            b = 'X'
        row_a, col_a = find_position(matrix, a)
        row_b, col_b = find_position(matrix, b)

        # Apply Playfair Cipher rules
        if row_a == row_b:
            encrypted_text += matrix[row_a][(col_a + 1) % 5]
            encrypted_text += matrix[row_b][(col_b + 1) % 5]
        elif col_a == col_b:
            encrypted_text += matrix[(row_a + 1) % 5][col_a]
            encrypted_text += matrix[(row_b + 1) % 5][col_b]
        else:
            encrypted_text += matrix[row_a][col_b]
            encrypted_text += matrix[row_b][col_a]

        i += 2

    return encrypted_text

# Example usage
key = "KEYWORD"
text = "HELLO"
matrix = create_playfair_matrix(key)
encrypted = playfair_encrypt(text, matrix)
print(f"Encrypted Text: {encrypted}")

#2. Hill Cipher (Python)

import numpy as np

def hill_encrypt(message, key_matrix):
    # Convert message to numerical values (A=0, B=1, ..., Z=25)
    message_vector = [ord(char) - 65 for char in message.upper()]
    message_vector = np.array(message_vector).reshape(-1, len(key_matrix))

    # Encrypt by matrix multiplication
    cipher_matrix = (np.dot(message_vector, key_matrix) % 26).flatten()
    encrypted_text = ''.join([chr(num + 65) for num in cipher_matrix])

    return encrypted_text

# Example usage
key_matrix = np.array([[6, 24], [1, 13]])  # 2x2 key matrix
message = "HI"
encrypted = hill_encrypt(message, key_matrix)
print(f"Encrypted Text: {encrypted}")

#3 Keyless Transposition Cipher
def keyless_transposition_encrypt(text):
    # Split text into even and odd indexed characters
    even_chars = text[0::2]
    odd_chars = text[1::2]
    return even_chars + odd_chars

# Example usage
text = "HELLO"
encrypted_text = keyless_transposition_encrypt(text)
print(f"Encrypted Text: {encrypted_text}")

#4. Additive Cipher (Python)
def additive_encrypt(text, shift):
    encrypted_text = ""
    for char in text.upper():
        if char.isalpha():
            encrypted_text += chr(((ord(char) - 65 + shift) % 26) + 65)
    return encrypted_text

# Example usage
text = "HELLO"
shift = 3
encrypted = additive_encrypt(text, shift)
print(f"Encrypted Text: {encrypted}")

#5. Key Generation Algorithm of DES (Python Skeleton)
def des_key_generation(key):
    # Placeholder for key generation logic
    # Perform permutations and shifts to generate subkeys
    subkeys = ["Subkey1", "Subkey2", "Subkey3"]
    return subkeys

# Example usage
key = "133457799BBCDFF1"
subkeys = des_key_generation(key)
print(f"Generated Subkeys: {subkeys}")

pip install pycryptodome

# Import necessary modules


from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes

# Set AES block size and key size
BLOCK_SIZE = 16  # AES block size is 128 bits
KEY_SIZE = 16  # AES-128 uses a 16-byte (128-bit) key (use 24 for AES-192 or 32 for AES-256)

# Generate a random AES key
key = get_random_bytes(KEY_SIZE)
print(f"AES Key: {key.hex()}")

# Generate a random Initialization Vector (IV)
iv = get_random_bytes(BLOCK_SIZE)
print(f"IV: {iv.hex()}")

# Function to encrypt data
def aes_encrypt(data, key, iv):
    # Initialize AES cipher in CBC mode
    cipher = AES.new(key, AES.MODE_CBC, iv)

    # Pad data to be a multiple of BLOCK_SIZE
    padded_data = pad(data.encode(), BLOCK_SIZE)

    # Encrypt the padded data
    ciphertext = cipher.encrypt(padded_data)

    return ciphertext

# Function to decrypt data
def aes_decrypt(ciphertext, key, iv):
    # Initialize AES cipher in CBC mode
    cipher = AES.new(key, AES.MODE_CBC, iv)

    # Decrypt the ciphertext
    decrypted_data = cipher.decrypt(ciphertext)

    # Unpad the decrypted data
    unpadded_data = unpad(decrypted_data, BLOCK_SIZE)

    return unpadded_data.decode()

# Example usage
if __name__ == "__main__":
    # Input data to encrypt
    plaintext = "This is a secret message."
    print(f"Plaintext: {plaintext}")

    # Encrypt the data
    encrypted_data = aes_encrypt(plaintext, key, iv)
    print(f"Encrypted Data: {encrypted_data.hex()}")

    # Decrypt the data
    decrypted_data = aes_decrypt(encrypted_data, key, iv)
    print(f"Decrypted Data: {decrypted_data}")

#7 Keyed Cipher (Example Using Caesar Cipher)
def keyed_cipher_encrypt(text, key):
    return additive_encrypt(text, key)

# Example usage
text = "HELLO"
key = 5
encrypted_text = keyed_cipher_encrypt(text, key)
print(f"Encrypted Text: {encrypted_text}")

#8. Diffie-Hellman Key Exchange (Python)
def diffie_hellman(p, g, private_a, private_b):
    # Calculate public keys
    public_a = (g ** private_a) % p
    public_b = (g ** private_b) % p

    # Calculate shared secret
    shared_secret_a = (public_b ** private_a) % p
    shared_secret_b = (public_a ** private_b) % p

    return shared_secret_a, shared_secret_b

# Example usage
p = 23  # Prime number
g = 5   # Primitive root
private_a = 6
private_b = 15
shared_a, shared_b = diffie_hellman(p, g, private_a, private_b)
print(f"Shared Secret: {shared_a}")

#9
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Random import get_random_bytes

def rsa_encrypt_decrypt(message):
    key = RSA.generate(2048)
    cipher = PKCS1_OAEP.new(key)
    ciphertext = cipher.encrypt(message.encode())
    plaintext = cipher.decrypt(ciphertext)
    return ciphertext, plaintext

# Example usage:
message = "HELLO"
ciphertext, plaintext = rsa_encrypt_decrypt(message)
print("Ciphertext:", ciphertext)
print("Plaintext:", plaintext.decode())

#10. Multiplicative Cipher (Python)
def multiplicative_encrypt(text, key):
    encrypted_text = ""
    for char in text.upper():
        if char.isalpha():
            encrypted_text += chr(((ord(char) - 65) * key % 26) + 65)
    return encrypted_text

# Example usage
text = "HELLO"
key = 5
encrypted = multiplicative_encrypt(text, key)
print(f"Encrypted Text: {encrypted}")

#11. Affine Cipher (Python)
def affine_encrypt(text, a, b):
    encrypted_text = ""
    for char in text.upper():
        if char.isalpha():
            encrypted_text += chr(((a * (ord(char) - 65) + b) % 26) + 65)
    return encrypted_text

# Example usage
text = "HELLO"
a = 5
b = 8
encrypted = affine_encrypt(text, a, b)
print(f"Encrypted Text: {encrypted}")

Here's a detailed explanation of the provided code, which includes multiple encryption techniques. Each section explains the functions and methods as might be expected in a viva.

---

### 1. Playfair Cipher Implementation

**Code Explanation:**

- **`create_playfair_matrix(key)`**: This function generates a 5x5 matrix based on a keyword for Playfair Cipher.
  - Converts `key` to uppercase and replaces "J" with "I" (Playfair Cipher convention).
  - Creates an empty `matrix` list and a `seen` set to track unique characters.
  - Adds characters from `key` to `matrix`, skipping any duplicates or non-alphabet characters.
  - Completes the matrix with remaining letters from "A" to "Z", excluding "J".
  - Converts `matrix` list into a 5x5 format.

- **`find_position(matrix, char)`**: Finds the row and column of a character in the 5x5 matrix.
  - Iterates through each cell in the matrix, returning the (row, column) pair when `char` is found.

- **`playfair_encrypt(text, matrix)`**: Encrypts the `text` using the Playfair Cipher.
  - Converts `text` to uppercase and removes spaces.
  - Pairs up characters. If characters in a pair are the same, the second character is replaced with "X".
  - Retrieves positions of each pair in the matrix.
    - If both characters are in the same row, each character shifts right.
    - If both characters are in the same column, each character shifts down.
    - Otherwise, characters form a rectangle, so each one swaps to the other’s column.
  - The encrypted text is generated pair by pair.

**Example Usage**:
Encrypts "HELLO WORLD" with a key "KEYWORD".

---

### 2. Hill Cipher Implementation

**Code Explanation**:

- **`hill_encrypt(message, key_matrix)`**: Implements Hill Cipher encryption using matrix multiplication.
  - Converts `message` to numerical form (A=0, B=1, etc.).
  - Reshapes `message_vector` to match the dimensions of `key_matrix`.
  - Multiplies `message_vector` with `key_matrix`, applies modulo 26, and flattens the result.
  - Converts numbers back to letters to form `encrypted_text`.

**Example Usage**:
Encrypts the message "HI" using a 2x2 matrix key `[[6, 24], [1, 13]]`.

---

### 3. Keyless Transposition Cipher

**Code Explanation**:

- **`keyless_transposition_encrypt(text)`**: A simple transposition cipher without a key.
  - Separates characters at even and odd positions.
  - Joins them in `even_chars + odd_chars` order to form the encrypted message.

**Example Usage**:
Encrypts "HELLO" by reordering characters.

---

### 4. Additive Cipher

**Code Explanation**:

- **`additive_encrypt(text, shift)`**: Applies an additive (Caesar) cipher with a given shift.
  - Shifts each letter in `text` by `shift` positions in the alphabet.
  - Converts letters back to characters and appends them to `encrypted_text`.

**Example Usage**:
Encrypts "HELLO" with a shift of 3.

---

### 5. DES Key Generation Skeleton

**Code Explanation**:

- **`des_key_generation(key)`**: A placeholder function to illustrate the concept of DES key generation.
  - Typically, it would use permutations and shifts to generate multiple subkeys for DES encryption.

**Example Usage**:
Demonstrates subkey generation with a sample key.

---

### 6. AES Encryption and Decryption

**Code Explanation**:

- **`aes_encrypt(data, key, iv)`**: Encrypts data using AES in CBC mode.
  - Initializes the AES cipher with `key` and `iv`.
  - Pads `data` to make it a multiple of block size, encrypts it, and returns `ciphertext`.

- **`aes_decrypt(ciphertext, key, iv)`**: Decrypts data using AES in CBC mode.
  - Decrypts `ciphertext`, removes padding, and returns the decrypted text.

**Example Usage**:
Encrypts and decrypts "This is a secret message." using a randomly generated AES key and IV.

---

### 7. Keyed Cipher with Caesar Cipher

**Code Explanation**:

- **`keyed_cipher_encrypt(text, key)`**: Demonstrates a keyed cipher by calling `additive_encrypt`.
  - Uses `additive_encrypt` to apply Caesar Cipher based on a numeric `key`.

**Example Usage**:
Encrypts "HELLO" with a shift key of 5.

---

### 8. Diffie-Hellman Key Exchange

**Code Explanation**:

- **`diffie_hellman(p, g, private_a, private_b)`**: Implements Diffie-Hellman Key Exchange to calculate shared secret.
  - Computes public keys for two parties and calculates a shared secret.

**Example Usage**:
Calculates shared secret using prime `p=23` and base `g=5`.

---

### 9. RSA Encryption and Decryption

**Code Explanation**:

- **`rsa_encrypt_decrypt(message)`**: Uses RSA to encrypt and decrypt a message.
  - Generates RSA key pair, encrypts `message`, and then decrypts it.

**Example Usage**:
Encrypts and decrypts "HELLO" using RSA.

---

### 10. Multiplicative Cipher

**Code Explanation**:

- **`multiplicative_encrypt(text, key)`**: Applies a multiplicative cipher.
  - Multiplies each letter's position by `key`, then applies modulo 26.

**Example Usage**:
Encrypts "HELLO" with a multiplicative key of 5.

---

### 11. Affine Cipher

**Code Explanation**:

- **`affine_encrypt(text, a, b)`**: Applies Affine Cipher encryption.
  - Uses the formula `(a * letter_position + b) % 26` to compute each character's encrypted form.

**Example Usage**:
Encrypts "HELLO" using `a=5` and `b=8`.

---

Each function provides a different approach to encryption, demonstrating both classical and modern cryptographic techniques.